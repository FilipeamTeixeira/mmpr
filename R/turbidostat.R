#' Load turbidostat data from a, with pyCultivator generated, SQLITE file
#'
#' @param path A string with the path to the data file
#' @param t_zero A string representing the zero timepoint or NA
#' when the first timepoint in the dataset should be taken as zero
#' @param time_fmt Format to use when parsing Date/Time string
#'
#' @export
load_turbidostat_sqlite <- function(
  path, t_zero=NA, time_fmt="%Y-%m-%d %H:%M:%S"
) {
  data <- data.frame()
  if (file.exists(path)) {

    #data_db <- src_sqlite(path, create = FALSE) old

    con <- DBI::dbConnect(RSQLite::SQLite(), path)
    # Replace src_sqlite() with tbl() and pass the database connection
    data_db <- tbl(con, "turbidostat")

    #if ("turbidostat" %in% src_tbls(data_db)) { old
    if ("turbidostat" %in% DBI::dbListTables(con)) {
      #data <- collect(tbl(data_db, "turbidostat"), n = Inf) old
      data <- parse_turbidostat(data, t_zero, time_fmt)

      # Close the database connection
      DBI::dbDisconnect(con)

    } else {
      warning("No turbidostat table in data")
    }
  }
  return(data)
}

#' Combine turbidostat data with normal cultivation data
#'
#' @param od.data A data.frame with od data
#' @param tb.data A data.frame with turbidostat data
#' @param method Method of combining
#' @param ... extra arguments passes to other functions
#'
#' @export
combine_turbidostat <- function(
  df.od, df.tb, method="id", keys=c("experiment_id", "channel"), ...
) {

  df.od <- df.od %>%
    rename(measurement_id = id)

  df.tb <- df.tb %>%
    select(
      !!keys,
      measurement_id, turbidostat_id = id, pump, decision, time_h
    )

  return(
    switch(
      method,
      "id" = combine_turbidostat_ids(df.od, df.tb, keys = keys, ...),
      "time" = combine_turbidostat_time(df.od, df.tb, keys=keys, ...)
    )
  )
}

#' Merge by id
combine_turbidostat_ids <- function(
  df.od, df.tb, keys=c("experiment_id", "channel")
) {

  if (!("measurement_id" %in% keys)) {
    keys <- c(keys, "measurement_id")
  }

  return(
    left_join(
      df.od,
      df.tb %>% select(-time_h),
      by=keys
    )
  )
}

#' Merge by time
combine_turbidostat_time <- function(
  df.od, df.tb, keys=c("experiment_id", "channel"), interval=5/60, sync_time=F
) {

  if (sync_time) {
    df.od <- df.od %>%
      mutate( time_h = time_h - time_h[0])
    df.tb <- df.tb %>%
      mutate( time_h = time_h - time_h[0])
  }

  df.od <- df.od %>%
    group_by_(keys) %>%
    mutate( time_h = time_h / interval)

  df.tb <- df.tb %>%
    group_by_(keys) %>%
    mutate( time_h = time_h / interval)

  # add time as key if not
  if (!("time_h" %in% keys)) {
    keys <- c(keys, "time_h")
  }

  return(
    left_join(
      df.od,
      df.tb %>% select(-measurement_id),
      by=keys
    ) %>%
      mutate( time_h = time_h * interval)
  )
}

#' Parse data obtained from a turbidostat SQLite file,
#'   generated by pyCultivator
#'
#' @param data data.frame with turbidostat data to parse.
#' @param t_zero timestamp of experiment startpoint
#'   if NA, determine from data
#' @param time_fmt character format specifiction of t_zero.
#'
#' @export
parse_turbidostat <- function(
  data, t_zero=NA, time_fmt="%Y-%m-%d %H:%M:%S"
) {
  if (is.na(t_zero)) {
    t_zero <- as.character((data %>% arrange(time))$time[[1]])
  }

  data$experiment_id <- as.numeric(data$experiment_id)
  data$channel_id <- as.numeric(data$channel_id)
  data$measurement_id <- as.numeric(data$measurement_id)

  data <- data %>%
    rename(OD = od_value, channel = channel_id) %>%
    group_by(channel) %>%
    arrange(time) %>%
    mutate( time_h = as.numeric(difftime(
      readr::parse_datetime(time, time_fmt),
      readr::parse_datetime(t_zero, time_fmt), units = "hours"
    ))) %>%
    filter(time_h >= 0)

  # count the decisions
  data <- data %>%
    group_by(experiment_id, channel) %>%
    arrange(time_h) %>%
    mutate(
      pump = decision,
      decision = count_occurence(decision, 1, F)
    )

  return(data)
}

#' Count occurences of a value in a vector
#'
#' @param values a vector with all the values
#' @param value the value to count
#' @param include whether to include the occurence when counting
#'
#' @export
count_occurence <- function(
  values, value = "True", include = TRUE
) {
  i <- 0
  sapply( values, function(x) {
    v <- i
    if (!is.na(x) & x == value) {
      i <<- i + 1
      if (include) {
        # reflect increase at current data point
        v <- i
      }
    }
    return(v)
  } )
}

#' Count the occurence of a value in a column of a data.frame
#'
#' @param data data.frame with the data to count occurences in
#' @param column name of the column to count occurences in
#' @param value the value to count, i.e. if this value is seen add 1 to count
#' @param include whether to increase the count at that position or 1 position later
#' @param .to name of the column to store the count value in
#'
#' @export
count_occurence_in <- function(
  data, column, value = 1, include = T, .to="count"
) {

  column <- enquo(column) %>% resolve_quosure()
  .to <- enquo(.to) %>% resolve_quosure()

  if (!(quo_name(column) %in% colnames(data)))
    stop(sprintf("Column '%s' does not exist in given data.frame", quo_name(column)))

  data %>%
    mutate( !!quo_name(.to) := count_occurence(UQ(column), value, include=include))
}

